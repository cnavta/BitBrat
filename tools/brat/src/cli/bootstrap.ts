import fs from 'fs';
import path from 'path';
import { loadArchitecture } from '../config/loader';
import { Logger } from '../orchestration/logger';

export interface BootstrapOptions {
  name: string;
  force?: boolean;
  mcp?: boolean;
}

function ensureDir(dir: string) {
  fs.mkdirSync(dir, { recursive: true });
}

function writeFileSafe(filePath: string, content: string, force = false): { skipped: boolean; path: string } {
  if (fs.existsSync(filePath) && !force) {
    return { skipped: true, path: filePath };
  }
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, content, 'utf8');
  return { skipped: false, path: filePath };
}

function toPascal(name: string): string {
  const parts = String(name)
    .trim()
    .replace(/[^a-zA-Z0-9]+/g, ' ')
    .split(' ')
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1).toLowerCase());
  return parts.join('');
}

function generateAppSource(serviceName: string, stubPaths: string[], consumedTopics: string[] = [], useMcp = false): string {
  const SERVICE_NAME = serviceName;
  const ClassName = `${toPascal(serviceName)}Server`;
  const explicitHandlers = Array.isArray(stubPaths) && stubPaths.length > 0
    ? stubPaths.map((p) => `    app.get('${p}', (_req: Request, res: Response) => { res.status(200).end(); });`).join('\n')
    : '';
  
  const consumedList = Array.isArray(consumedTopics) ? consumedTopics : [];
  const perTopicSubscriptions = consumedList.length
    ? consumedList.map((t) => `
      { // subscription for ${t}
        const raw = ${JSON.stringify(t)};
        try {
          // TODO: implement domain behavior for this topic
          this.getLogger().info('${SERVICE_NAME}.subscribe.ok', { destination: raw });
        } catch (e: any) {
          this.getLogger().error('${SERVICE_NAME}.subscribe.error', { destination: raw, error: e?.message || String(e) });
        }
      }`).join('\n')
    : '';
  
  const baseClass = useMcp ? 'McpServer' : 'BaseServer';
  const baseImportPath = useMcp ? '../common/mcp-server' : '../common/base-server';
  const zodImport = useMcp ? "import { z } from 'zod';\n" : "";
  const mcpToolExample = useMcp ? `
    // Example MCP tool registration
    this.registerTool(
      'echo',
      'Echoes back the input',
      z.object({
        message: z.string().describe('The message to echo'),
      }),
      async (args) => {
        return {
          content: [{ type: 'text', text: args.message }],
        };
      }
    );
` : "";

  return `import { Request, Response } from 'express';
${zodImport}import { ${baseClass} } from '${baseImportPath}';

/**
 * ${ClassName}
 * Generated by brat service bootstrap.
 */
export class ${ClassName} extends ${baseClass} {
  constructor() {
    super();
    this.setupRoutes();
  }

  private setupRoutes() {
    const app = this.getApp();
${explicitHandlers}
    // Standard health check
    app.get('/health', (_req: Request, res: Response) => {
      res.status(200).json({ status: 'ok', service: '${SERVICE_NAME}' });
    });
  }

  public async close(reason: string = 'manual'): Promise<void> {
    await super.close(reason);
  }
}

if (require.main === module) {
  const server = new ${ClassName}();
  const port = parseInt(process.env.PORT || '8080', 10);
  server.start(port).catch((err) => {
    console.error('Failed to start ${SERVICE_NAME}:', err);
    process.exit(1);
  });
}
`;
}

function generateTest(serviceName: string, entry: string): string {
  const entryFilename = path.basename(entry).replace(/\.ts$/, '');
  return `import request from 'supertest';
import { ${toPascal(serviceName)}Server } from './${entryFilename}';

describe('${serviceName}', () => {
  let server: ${toPascal(serviceName)}Server;

  beforeAll(async () => {
    server = new ${toPascal(serviceName)}Server();
    // We don't necessarily need to call server.start() if we just want to test routes via supertest
  });

  afterAll(async () => {
    await server.close('test');
  });

  it('GET /health returns 200', async () => {
    const response = await request(server.getApp()).get('/health');
    expect(response.status).toBe(200);
    // BaseServer response might differ slightly if it uses registerHealth, but let's assume our override for now
    expect(response.body.status).toBe('ok');
  });
});
`;
}

function generateDockerfile(serviceName: string, entry: string): string {
  const entryBase = entry.replace(/\.ts$/, '');
  return `FROM node:24-slim AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:24-slim
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY --from=builder /app/dist ./dist
# We need architecture.yaml for McpServer/BaseServer
COPY architecture.yaml ./

ENV NODE_ENV=production
ENV SERVICE_NAME=${serviceName}

CMD ["node", "dist/${entryBase}.js"]
`;
}

function generateCompose(serviceName: string, port: number): string {
  return `services:
  ${serviceName}:
    build:
      context: .
      dockerfile: Dockerfile.${serviceName}
    ports:
      - "\${${serviceName.toUpperCase().replace(/-/g, '_')}_HOST_PORT:-${port}}:\${SERVICE_PORT:-${port}}"
    environment:
      - NODE_ENV=local
      - BITBRAT_ENV=local
      - PORT=\${SERVICE_PORT:-${port}}
    env_file:
      - .env.local
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:\${SERVICE_PORT:-${port}}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    depends_on:
      nats:
        condition: service_healthy
      firebase-emulator:
        condition: service_healthy
    networks:
      - bitbrat-network

networks:
  bitbrat-network:
    external: true
`;
}

export async function cmdServiceBootstrap(opts: BootstrapOptions, log: Logger) {
  const root = process.cwd();
  const arch = loadArchitecture(root);
  const svc = arch.services[opts.name];

  if (!svc) {
    throw new Error(`Service "${opts.name}" not found in architecture.yaml`);
  }

  // If entry exists in arch, use it. Otherwise default to src/apps/<name>.ts
  const entry = svc.entry || `src/apps/${opts.name}.ts`;
  const port = svc.port || 8080;
  // Use 'any' cast to access non-standard fields if they exist in raw architecture.yaml
  const paths = (svc as any).paths || [];
  const consumes = (svc as any).consumes || [];

  log.info({ service: opts.name, entry, mcp: !!opts.mcp }, 'Bootstrapping service');

  const results: any[] = [];

  // 1. App Source
  const appSrc = generateAppSource(opts.name, paths, consumes, opts.mcp);
  results.push(writeFileSafe(path.join(root, entry), appSrc, opts.force));

  // 2. Unit Test
  const testPath = entry.replace(/\.ts$/, '.test.ts');
  const testSrc = generateTest(opts.name, entry);
  results.push(writeFileSafe(path.join(root, testPath), testSrc, opts.force));

  // 3. Dockerfile
  const dockerfile = generateDockerfile(opts.name, entry);
  results.push(writeFileSafe(path.join(root, `Dockerfile.${opts.name}`), dockerfile, opts.force));

  // 4. Docker Compose
  const compose = generateCompose(opts.name, port);
  results.push(writeFileSafe(path.join(root, 'infrastructure', 'docker-compose', 'services', `${opts.name}.compose.yaml`), compose, opts.force));

  for (const r of results) {
    if (r.skipped) {
      log.warn({ path: r.path }, 'Skipped (exists)');
    } else {
      log.info({ path: r.path }, 'Created');
    }
  }

  log.info({ service: opts.name }, 'Bootstrap complete');
}
