Technical Architecture — Command Processor Service (Architect)

Date: 2025-11-30 21:56 UTC
Sprint: sprint-108-bc7a2d
Branch: feature/sprint-108-bc7a2d-command-processor-architecture

Objective
- Implement the first-pass Command Processor that:
  - Consumes internal.command.v1 events (InternalEventV2 preferred; V1 tolerated via adapter).
  - Detects commands prefixed by a configurable sigil (default: "!").
  - Resolves command by canonical name or any alias against Firestore.
  - Evaluates optional controls: global cooldown, user cooldown, and rate limit.
  - Renders a response from one of the configured templates (not the previously used one when possible).
  - Appends the rendered response as a CandidateV1 to the event and advances the routing slip.

In/Out of Scope
- In scope: parsing, lookup, cooldown/rate-limit checks, template rendering, candidate append, routing-slip advancement, observability, error handling.
- Out of scope: invoking external tools/actions, complex templating logic, multi-region contention mitigation beyond Firestore transactions, admin/CRUD UI for commands.

Contracts & Topics
- Consumes topic: internal.command.v1 (see architecture.yaml/services/command-processor)
- Event schema: InternalEventV2 (src/types/events.ts)
  - For V1 payloads, service will up-convert via toV2 adapter.
- Candidate schema: CandidateV1 with kind: 'text', source: 'command-processor', status: 'proposed'.

Configuration
- ENV: COMMAND_SIGIL (default: !)
- ENV: BOT_USERNAME (bot display name for templates)
- ENV: COMMANDS_COLLECTION (default: commands)
- ENV (optional defaults; may be omitted to disable):
  - DEFAULT_GLOBAL_COOLDOWN_MS (default: 0 = disabled)
  - DEFAULT_USER_COOLDOWN_MS (default: 0 = disabled)
  - DEFAULT_RATE_MAX (default: 0 = disabled)
  - DEFAULT_RATE_PER_MS (default: 60000 = 1 min)
- Uses existing message-bus env from architecture.yaml defaults (LOG_LEVEL, MESSAGE_BUS_DRIVER, NATS_URL, BUS_PREFIX).

Firestore Data Model (first pass)
Collection: commands
- Document ID: auto-generated by Firestore
- Fields:
  - name: string (canonical, lowercase; e.g., "so")
  - description?: string
  - aliases?: string[] (lowercase)
  - templates: { id: string; text: string }[]
  - cooldowns?: {
        globalMs?: number;        // overrides default; 0 or undefined disables
        perUserMs?: number;       // overrides default; 0 or undefined disables
    }
  - rateLimit?: {
        max: number;              // 0 disables
        perMs: number;            // window length in ms
    }
  - runtime?: {
        lastUsedTemplateId?: string; // optional; best-effort anti-repeat
        lastExecutionAt?: string;    // ISO8601; used for global cooldown
    }

Runtime state (subcollections) — to support distributed cooldowns without shared memory:
- cooldowns/users/{userId}: { lastExecutionAt: string }
- rate-limits/windows/{windowKey}: { count: number, windowStartAt: string }
  - windowKey example: 2025-11-30T21:56:00Z@60000 (start@windowMs)

Notes:
- All updates that gate execution (cooldowns/rate) occur within Firestore transactions to avoid races across instances.
- Reads should index by name and aliases via a composite query (see Lookup below).

Lookup & Matching
1) Parse message text; if it does not start with COMMAND_SIGIL, mark current routing step SKIP and advance (no candidate produced).
2) Extract commandName = firstToken.substring(sigil.length).toLowerCase() and args = rest.
3) Query Firestore:
   - Primary: commands where name == commandName limit 1
   - If none: commands where aliases array contains commandName limit 1
   - Prefer cached index lookups; ensure single-field index on name and array-contains index on aliases.

Cooldown & Rate Limiting Semantics
- Global Cooldown: minimum time between any executions of the command.
  - Effective value: doc.cooldowns.globalMs ?? DEFAULT_GLOBAL_COOLDOWN_MS.
  - Enforced by comparing now to runtime.lastExecutionAt within a transaction.
- Per-User Cooldown: minimum time between executions per user.
  - Effective value: doc.cooldowns.perUserMs ?? DEFAULT_USER_COOLDOWN_MS.
  - Stored/checked at cooldowns/users/{userId} with lastExecutionAt.
- Rate Limit: max executions in a window (fixed windows for first pass).
  - Effective: doc.rateLimit || (DEFAULT_RATE_MAX>0 ? {max:DEFAULT_RATE_MAX, perMs:DEFAULT_RATE_PER_MS}: disabled).
  - Implemented with window buckets under rate-limits/windows/{windowKey}; transaction increments count if < max.

Notes:
- Fixed windows chosen for simplicity and Firestore friendliness; can be upgraded to true sliding windows later.
- All checks are short-circuited: first violation stops processing (no candidate), advances routing with status:'SKIP' and an annotation/error entry.

Template Selection & Rendering
- Template choice:
  - If multiple templates, choose randomly from those not equal to runtime.lastUsedTemplateId; if all match last used (degenerate), allow any.
  - Persist chosen lastUsedTemplateId and update runtime.lastExecutionAt in the same transaction that clears cooldown checks.
- Allowed variables in text:
  - {{botName}} → BOT_USERNAME
  - {{username}} → event.user?.displayName || event.userId || 'user'
  - {{utcNow}} → current UTC time (ISO8601)
- Rendering engine: minimal mustache-like replacer (no logic/sections) to avoid code injection; treat rendered text as plain text.

Candidate Production
Create a CandidateV1 and push onto event.candidates:
- id: ULID/UUID
- kind: text
- source: command-processor
- createdAt: now.toISOString()
- status: proposed
- priority: 100 (default priority for command replies)
- text: rendered template output
- metadata (optional): { commandName, templateId, args, checks: { globalCooldownMs, perUserMs, rate: { max, perMs } } }

Routing Slip Advancement
- If event has a routingSlip with a current step for this service, set status to OK (or SKIP on no-op/violations), write endedAt.
- Determine next hop:
  - If there are remaining steps with status:'PENDING', publish to that step’s nextTopic.
  - Else, publish to egressDestination if present; otherwise, log and finish.
- This becomes the standard behavior candidate for all services later; this service implements it now.

Error Handling
- JSON parse or schema errors: log, ack, and advance with error entry; do not requeue.
- Transient Firestore errors: nack with requeue (bounded retries via message bus).
- Template not found, command missing, or policy violations: mark step SKIP, annotate with reason, advance.

Observability & Logging
- Use logging facade (logger) with structured fields: correlationId, type, source, routingStep.id, status.
- Key events:
  - command_processor.event.received
  - command_processor.command.matched (name/id)
  - command_processor.policy.blocked (which policy; values)
  - command_processor.template.chosen (templateId)
  - command_processor.candidate.added (candidateId)
  - command_processor.advance.next (topic or egress)
  - command_processor.process_error

Security
- Service uses server credentials with firebase-admin; Firestore rules should restrict command docs to server-only access.
- Validate and sanitize all rendered values; no user-provided HTML/Markdown is interpreted by the service.

Testing Strategy
- Unit tests:
  - Parsing and sigil detection
  - Alias lookup precedence (name vs alias)
  - Cooldown and per-user cooldown enforcement
  - Rate limiting window behavior
  - Template selection anti-repeat
  - Rendering of variables and escaping
  - Candidate append shape
  - Routing advancement paths (next topic vs egress)
- Integration smoke:
  - V1→V2 adapter path
  - End-to-end event consumption to candidate append (message-bus disabled network I/O)

Deployment & Runtime
- Cloud Run (managed), Node.js 24.x, ports/health per architecture.yaml defaults.
- Env variables as above; no external network calls required beyond Firestore and bus.

Open Questions / Future Enhancements
- Migrate fixed-window rate limiting to true sliding window or token bucket with shared state (Redis/MemoryStore).
- Per-channel overrides for BOT_USERNAME and policy defaults.
- Templating i18n and localization.
- Command execution side-effects (actions) and permissions.

Acceptance Criteria
- Given a chat message with leading COMMAND_SIGIL and a configured command, the service appends a CandidateV1 with rendered text and advances the routing slip per rules above.
- Violations (cooldown/rate) result in SKIP status and appropriate annotations, with routing advanced.
- Non-command messages are marked SKIP and advanced without candidate.
